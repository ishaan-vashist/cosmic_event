import { z } from "zod";
import { NEO, DayGroup, Approach, SortOrder } from "@/types/neo";

// Type for API errors with additional properties
interface ApiError extends Error {
  status: number;
  headers: Headers;
}

// NASA API base URL
const NASA_API_BASE = "https://api.nasa.gov/neo/rest/v1";

/**
 * Schema for validating NASA API response structure
 */
const NasaApproachSchema = z.object({
  close_approach_date: z.string(),
  close_approach_date_full: z.string().nullable().optional(),
  epoch_date_close_approach: z.number().nullable().optional(),
  relative_velocity: z.object({
    kilometers_per_second: z.string().nullable().optional(),
  }).optional(),
  miss_distance: z.object({
    kilometers: z.string().nullable().optional(),
  }).optional(),
  orbiting_body: z.string().nullable().optional(),
});

const NasaNeoSchema = z.object({
  id: z.string(),
  neo_reference_id: z.string(),
  name: z.string(),
  nasa_jpl_url: z.string().url().nullable().optional(),
  is_potentially_hazardous_asteroid: z.boolean(),
  estimated_diameter: z.object({
    kilometers: z.object({
      estimated_diameter_min: z.number(),
      estimated_diameter_max: z.number(),
    }),
  }),
  close_approach_data: z.array(NasaApproachSchema),
});

const NasaFeedSchema = z.object({
  element_count: z.number(),
  near_earth_objects: z.record(z.string(), z.array(NasaNeoSchema)),
});

const NasaDetailSchema = NasaNeoSchema.extend({
  orbital_data: z.record(z.string(), z.any()).optional(),
});

/**
 * Maximum number of retry attempts for API calls
 */
const MAX_RETRIES = 3;

/**
 * Delay between retry attempts (in milliseconds)
 */
const RETRY_DELAY = 1000;

/**
 * Mock data for offline fallback
 */
const MOCK_NEO_DATA = {
  "links": {
    "next": "https://api.nasa.gov/neo/rest/v1/feed?start_date=2025-08-18&end_date=2025-08-25&detailed=false&api_key=DEMO_KEY",
    "previous": "https://api.nasa.gov/neo/rest/v1/feed?start_date=2025-08-04&end_date=2025-08-11&detailed=false&api_key=DEMO_KEY",
    "self": "https://api.nasa.gov/neo/rest/v1/feed?start_date=2025-08-11&end_date=2025-08-18&detailed=false&api_key=DEMO_KEY"
  },
  "element_count": 10,
  "near_earth_objects": {
    "2025-08-15": [
      {
        "id": "3908907",
        "neo_reference_id": "3908907",
        "name": "(2025 KF)",
        "nasa_jpl_url": "http://ssd.jpl.nasa.gov/sbdb.cgi?sstr=3908907",
        "absolute_magnitude_h": 24.4,
        "estimated_diameter": {
          "kilometers": {
            "estimated_diameter_min": 0.0350392641,
            "estimated_diameter_max": 0.0783501764
          }
        },
        "is_potentially_hazardous_asteroid": true,
        "close_approach_data": [
          {
            "close_approach_date": "2025-08-15",
            "close_approach_date_full": "2025-Aug-15 07:35",
            "epoch_date_close_approach": 1755123300000,
            "relative_velocity": {
              "kilometers_per_second": "19.7498128142"
            },
            "miss_distance": {
              "kilometers": "14538544.896019833"
            },
            "orbiting_body": "Earth"
          }
        ]
      },
      {
        "id": "3986741",
        "neo_reference_id": "3986741",
        "name": "(2025 LB)",
        "nasa_jpl_url": "http://ssd.jpl.nasa.gov/sbdb.cgi?sstr=3986741",
        "absolute_magnitude_h": 22.9,
        "estimated_diameter": {
          "kilometers": {
            "estimated_diameter_min": 0.0699125232,
            "estimated_diameter_max": 0.1563291544
          }
        },
        "is_potentially_hazardous_asteroid": false,
        "close_approach_data": [
          {
            "close_approach_date": "2025-08-15",
            "close_approach_date_full": "2025-Aug-15 14:35",
            "epoch_date_close_approach": 1755148500000,
            "relative_velocity": {
              "kilometers_per_second": "21.9071531919"
            },
            "miss_distance": {
              "kilometers": "58188572.99149903"
            },
            "orbiting_body": "Earth"
          }
        ]
      }
    ],
    "2025-08-16": [
      {
        "id": "3759353",
        "neo_reference_id": "3759353",
        "name": "(2016 RU33)",
        "nasa_jpl_url": "http://ssd.jpl.nasa.gov/sbdb.cgi?sstr=3759353",
        "absolute_magnitude_h": 27.5,
        "estimated_diameter": {
          "kilometers": {
            "estimated_diameter_min": 0.008405334,
            "estimated_diameter_max": 0.0187948982
          }
        },
        "is_potentially_hazardous_asteroid": false,
        "close_approach_data": [
          {
            "close_approach_date": "2025-08-16",
            "close_approach_date_full": "2025-Aug-16 05:45",
            "epoch_date_close_approach": 1755204300000,
            "relative_velocity": {
              "kilometers_per_second": "3.7231614095"
            },
            "miss_distance": {
              "kilometers": "6331577.697085159"
            },
            "orbiting_body": "Earth"
          }
        ]
      }
    ]
  }
};

/**
 * Sleep function for implementing delay between retries
 * @param ms - Milliseconds to sleep
 */
const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));

/**
 * Creates a typed API error with status and headers
 * @param message - Error message
 * @param status - HTTP status code
 * @param headers - Response headers
 * @returns Typed ApiError object
 */
function createApiError(message: string, status: number, headers: Headers): ApiError {
  const error = new Error(message) as ApiError;
  error.status = status;
  error.headers = headers;
  return error;
}

/**
 * Fetches NEO feed data from NASA API for a given date range with retry mechanism
 * @param startDate - Start date in YYYY-MM-DD format
 * @param endDate - End date in YYYY-MM-DD format
 * @returns Raw NASA API response
 */
export async function fetchNeoFeed(startDate: string, endDate: string): Promise<z.infer<typeof NasaFeedSchema>> {
  const apiKey = process.env.NASA_API_KEY;
  
  if (!apiKey) {
    console.warn("NASA_API_KEY is not defined in environment variables, using demo key");
  }
  
  const url = `${NASA_API_BASE}/feed?start_date=${startDate}&end_date=${endDate}&api_key=${apiKey || 'DEMO_KEY'}`;
  
  let lastError: Error | null = null;
  
  // Implement retry logic
  for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
    try {
      // Add timeout to the fetch request
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
      
      const response = await fetch(url, { 
        signal: controller.signal,
        // Add headers that might help with connectivity issues
        headers: {
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache'
        }
      });
      
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        throw createApiError(`NASA API error: ${response.statusText}`, response.status, response.headers);
      }
      
      const data = await response.json();
      
      try {
        return NasaFeedSchema.parse(data);
      } catch (error) {
        console.error("NASA API response validation error:", error);
        throw new Error("Invalid data format received from NASA API");
      }
    } catch (error) {
      const err = error as Error & { code?: string };
      lastError = err;
      console.warn(`API fetch attempt ${attempt + 1} failed:`, err.message);
      
      // If this is a network connectivity error, wait and retry
      if (err.name === 'AbortError' || 
          err.message.includes('fetch failed') || 
          err.code === 'ENOTFOUND' || 
          err.code === 'ECONNREFUSED') {
        
        // If it's the last attempt, we'll fall through to the fallback
        if (attempt < MAX_RETRIES - 1) {
          // Wait with exponential backoff before retrying
          await sleep(RETRY_DELAY * Math.pow(2, attempt));
          continue;
        }
      } else {
        // For other types of errors, don't retry
        break;
      }
    }
  }
  
  // All retries failed, use mock data as fallback
  console.warn("All API fetch attempts failed, using mock data as fallback");
  console.info("Last error:", lastError);
  
  // Return mock data that matches the schema
  return NasaFeedSchema.parse(MOCK_NEO_DATA);
}

/**
 * Mock data for a single NEO detail (for fallback)
 */
const MOCK_NEO_DETAIL = {
  "id": "3908907",
  "neo_reference_id": "3908907",
  "name": "(2025 KF)",
  "nasa_jpl_url": "http://ssd.jpl.nasa.gov/sbdb.cgi?sstr=3908907",
  "absolute_magnitude_h": 24.4,
  "estimated_diameter": {
    "kilometers": {
      "estimated_diameter_min": 0.0350392641,
      "estimated_diameter_max": 0.0783501764
    }
  },
  "is_potentially_hazardous_asteroid": true,
  "close_approach_data": [
    {
      "close_approach_date": "2025-08-15",
      "close_approach_date_full": "2025-Aug-15 07:35",
      "epoch_date_close_approach": 1755123300000,
      "relative_velocity": {
        "kilometers_per_second": "19.7498128142"
      },
      "miss_distance": {
        "kilometers": "14538544.896019833"
      },
      "orbiting_body": "Earth"
    }
  ],
  "orbital_data": {
    "orbit_id": "1",
    "orbit_determination_date": "2025-08-15 07:35",
    "first_observation_date": "2025-08-15",
    "last_observation_date": "2025-08-15",
    "data_arc_in_days": 1,
    "observations_used": 10,
    "orbit_uncertainty": "1",
    "minimum_orbit_intersection": ".0378093",
    "jupiter_tisserand_invariant": "3.121",
    "epoch_osculation": "2459000.5",
    "eccentricity": ".5204050959770484",
    "semi_major_axis": "2.377065592818027",
    "inclination": "5.705556578053855",
    "ascending_node_longitude": "321.5450528906645",
    "orbital_period": "1339.580429836555",
    "perihelion_distance": "1.140132805395035",
    "perihelion_argument": "31.52962302905209",
    "aphelion_distance": "3.613998380241019",
    "perihelion_time": "2458492.626133078927",
    "mean_anomaly": "136.2364393831277",
    "mean_motion": ".2687339931142078",
    "equinox": "J2000"
  }
};

/**
 * Fetches detailed information about a specific NEO
 * @param id - NEO ID
 * @param withOrbit - Whether to include orbital data
 * @returns Normalized NEO detail
 */
export async function fetchNeoDetail(id: string, withOrbit: boolean): Promise<NEO> {
  const apiKey = process.env.NASA_API_KEY;
  
  if (!apiKey) {
    console.warn("NASA_API_KEY is not defined in environment variables, using demo key");
  }
  
  const url = `${NASA_API_BASE}/neo/${id}?api_key=${apiKey || 'DEMO_KEY'}`;
  
  let lastError: Error | null = null;
  
  // Implement retry logic
  for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {
    try {
      // Add timeout to the fetch request
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout
      
      const response = await fetch(url, { 
        signal: controller.signal,
        headers: {
          'Cache-Control': 'no-cache',
          'Pragma': 'no-cache'
        }
      });
      
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        throw createApiError(`NASA API error: ${response.statusText}`, response.status, response.headers);
      }
      
      const data = await response.json();
      
      // Validate response structure
      const validationResult = NasaDetailSchema.safeParse(data);
      if (!validationResult.success) {
        console.error("NASA API response validation failed:", validationResult.error);
        throw new Error("Invalid response format from NASA API");
      }
      
      // Convert to our normalized format
      const neo = normalizeNeo(data);
      
      // Include all approaches
      neo.approaches = data.close_approach_data.map(normalizeApproach);
      
      // Include orbital data if requested
      if (withOrbit && data.orbital_data) {
        neo.orbital_data = data.orbital_data;
      }
      
      return neo;
    } catch (error) {
      const err = error as Error & { code?: string };
      lastError = err;
      console.warn(`API fetch attempt ${attempt + 1} failed for NEO ${id}:`, err.message);
      
      // If this is a network connectivity error, wait and retry
      if (err.name === 'AbortError' || 
          err.message.includes('fetch failed') || 
          err.code === 'ENOTFOUND' || 
          err.code === 'ECONNREFUSED') {
        
        // If it's the last attempt, we'll fall through to the fallback
        if (attempt < MAX_RETRIES - 1) {
          // Wait with exponential backoff before retrying
          await sleep(RETRY_DELAY * Math.pow(2, attempt));
          continue;
        }
      } else {
        // For other types of errors, don't retry
        break;
      }
    }
  }
  
  // All retries failed, use mock data as fallback
  console.warn(`All API fetch attempts failed for NEO ${id}, using mock data as fallback`);
  console.info("Last error:", lastError);
  
  // Use mock data and modify it to match the requested ID
  const mockData = { ...MOCK_NEO_DETAIL, id, neo_reference_id: id };
  
  // Validate and normalize the mock data
  const validationResult = NasaDetailSchema.safeParse(mockData);
  if (!validationResult.success) {
    console.error("Mock data validation failed:", validationResult.error);
    throw new Error("Invalid mock data format");
  }
  
  // Convert to our normalized format
  const neo = normalizeNeo(mockData);
  
  // Include all approaches
  neo.approaches = mockData.close_approach_data.map(normalizeApproach);
  
  // Include orbital data if requested
  if (withOrbit && mockData.orbital_data) {
    neo.orbital_data = mockData.orbital_data;
  }
  
  return neo;
}

/**
 * Normalizes NASA API response into our application format
 * @param data - Raw NASA API response
 * @param hazardousOnly - Filter to only hazardous NEOs
 * @param sortOrder - Sort order for approaches
 * @returns Array of day groups with normalized NEOs
 */
export function normalizeNeoData(
  data: z.infer<typeof NasaFeedSchema>, 
  hazardousOnly: boolean = false,
  sortOrder: SortOrder = "approach_asc"
): DayGroup[] {
  const { near_earth_objects } = data;
  
  // Convert to day groups
  const dayGroups: DayGroup[] = Object.entries(near_earth_objects)
    .map(([date, neos]: [string, z.infer<typeof NasaNeoSchema>[]])=> {
      // Filter and normalize NEOs
      const normalizedNeos = neos
        .filter((neo: z.infer<typeof NasaNeoSchema>) => !hazardousOnly || neo.is_potentially_hazardous_asteroid)
        .map(normalizeNeo);
      
      // Sort NEOs based on requested sort order
      if (sortOrder === "approach_asc") {
        normalizedNeos.sort((a: NEO, b: NEO) => {
          if (!a.nearestApproach?.epoch) return 1;
          if (!b.nearestApproach?.epoch) return -1;
          return a.nearestApproach.epoch - b.nearestApproach.epoch;
        });
      } else if (sortOrder === "approach_desc") {
        normalizedNeos.sort((a: NEO, b: NEO) => {
          if (!a.nearestApproach?.epoch) return 1;
          if (!b.nearestApproach?.epoch) return -1;
          return b.nearestApproach.epoch - a.nearestApproach.epoch;
        });
      } else if (sortOrder === "size_asc") {
        normalizedNeos.sort((a: NEO, b: NEO) => {
          if (a.avgDiameterKm === null) return 1;
          if (b.avgDiameterKm === null) return -1;
          return a.avgDiameterKm - b.avgDiameterKm;
        });
      } else if (sortOrder === "size_desc") {
        normalizedNeos.sort((a: NEO, b: NEO) => {
          if (a.avgDiameterKm === null) return 1;
          if (b.avgDiameterKm === null) return -1;
          return b.avgDiameterKm - a.avgDiameterKm;
        });
      }
      
      return {
        date,
        count: normalizedNeos.length,
        neos: normalizedNeos,
      };
    })
    // Sort day groups by date (ascending)
    .sort((a, b) => a.date.localeCompare(b.date));
  
  return dayGroups;
}

/**
 * Normalizes a single NEO from NASA API format to our application format
 * @param neo - Raw NEO data from NASA API
 * @returns Normalized NEO object
 */
export function normalizeNeo(neo: z.infer<typeof NasaNeoSchema> | z.infer<typeof NasaDetailSchema>): NEO {
  // Calculate average diameter
  const minDiameter = neo.estimated_diameter?.kilometers?.estimated_diameter_min;
  const maxDiameter = neo.estimated_diameter?.kilometers?.estimated_diameter_max;
  const avgDiameterKm = minDiameter && maxDiameter 
    ? (minDiameter + maxDiameter) / 2 
    : null;
  
  // Find nearest approach (earliest by epoch)
  const approaches = neo.close_approach_data || [];
  let nearestApproach: Approach | null = null;
  
  if (approaches.length > 0) {
    // Sort by epoch and take the earliest
    const sortedApproaches = [...approaches].sort((a, b) => {
      const epochA = a.epoch_date_close_approach || Number.MAX_SAFE_INTEGER;
      const epochB = b.epoch_date_close_approach || Number.MAX_SAFE_INTEGER;
      return epochA - epochB;
    });
    
    nearestApproach = normalizeApproach(sortedApproaches[0]);
  }
  
  return {
    id: neo.id,
    name: neo.name,
    hazardous: neo.is_potentially_hazardous_asteroid,
    avgDiameterKm,
    nearestApproach,
    approachesCount: approaches.length,
    nasaUrl: neo.nasa_jpl_url || "",
  };
}

/**
 * Normalizes approach data from NASA API format
 * @param approach - Raw approach data from NASA API
 * @returns Normalized approach object
 */
export function normalizeApproach(approach: z.infer<typeof NasaApproachSchema>): Approach {
  // Create a properly formatted datetime string that can be parsed by date-fns
  let datetime = null;
  
  // First try to use the full date if available
  if (approach.close_approach_date_full) {
    // NASA API returns dates in format like "2025-Aug-15 07:35"
    // We'll keep this format as is and handle it in the formatting function
    datetime = approach.close_approach_date_full;
  } 
  // Fall back to just the date if that's all we have
  else if (approach.close_approach_date) {
    // If we only have the date without time, append a default time
    datetime = approach.close_approach_date;
  }
  
  return {
    datetime: datetime,
    epoch: approach.epoch_date_close_approach,
    velocityKps: approach.relative_velocity?.kilometers_per_second 
      ? parseFloat(approach.relative_velocity.kilometers_per_second)
      : null,
    missDistanceKm: approach.miss_distance?.kilometers 
      ? parseFloat(approach.miss_distance.kilometers)
      : null,
    orbitingBody: approach.orbiting_body || null,
  };
}
